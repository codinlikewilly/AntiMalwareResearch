import itertools


#takes input and returns possible motif sequences with length four 
def input_string(string):
    x = 0
    y = 4
    dna = []

    for a in range( len(string) + 1 ):
        if y == (len(string) + 1):
            break
        else:
            dna.append(string[x:y])
            x = x+1
            y = y+1
    return dna               
    


#uses hamming distance to find sequences that have no more than 1 mismatched letter
def hamming(a,b):
    return len([i for i in filter(lambda x: x[0] != x[1], zip(a, b))])

#take user input        
def take_input():
    return (input("sequence: " ))
    

#sanitize input remove duplicate results
def sanitize(s):
    return list(dict.fromkeys(s))

#check possible motifs against all possibilities 
def seq_list(lista,listb,outputlist):
    for n in lista:
        for x in listb:
            if ((hamming(n,x)) <= 1):
                   outputlist.append(x)
#finalize results by removing results in output lists that have hamming distance > 1
# when compared to other possible motifs 
def finalize(a,b,output):
        for x in a:
            for y in b:
                if ((hamming(x,y)) <= 1):
                    output.append(x)



                    
#############################################################################
                ##MAIN METHOD##                    
def main():
    #test run or run program?
    print("Test run (y/n)?")
    if (input() == "y"):
          seq1="ACTGACGCAG"
          seq2="TCACAACGGG"
          seq3="GAGTCCAGTT"
    else:
        seq1 = str(take_input())
        seq2 = str(take_input())
        seq3 = str(take_input())

    



    #Placeholders for list objects and components
    l1out = []
    l2out = []
    l3out = []
    out = []
    good = []

    
    #Generate possible motifs to be compared
    l1 = (input_string(seq1))
    l2 = (input_string(seq2))
    l3 = (input_string(seq3))


    #Generate all possible combinations of letters "ACGT"
    possibles = []
    a = "ACGT"
    for output in itertools.product(a, repeat=4):
        possibles.append(''.join(output))
        
    
    #Compare generated possible motifs with all combinations and place in output file
    seq_list(l1,possibles,l1out)
    seq_list(l2,possibles,l2out)
    seq_list(l3,possibles,l3out)
                
    
    #sanitize output (delete duplicate results)
    sanitize(l1out)
    sanitize(l2out)
    sanitize(l3out)
    
    #compare output to each other to make final output list
    finalize(l1out,l2,good)
    finalize(good,l3,out)

    # remove duplicate results from final output
    sanitize(good)


   
    # Display results
    print(sanitize(out))

main()
