import binascii
from textwrap import wrap





#function() tobinary()
#takes filepath as argument, reads file and returns raw binary of file

def tobinary(FP):
    with open(FP, 'rb') as fobj:
        raw_bytes = fobj.read()
        binary = str(' '.join(map(lambda x: '{:08b}'.format(x), raw_bytes)))
        return (binary.replace(" ",""))

    #function generateseq()
    #takes binary from tobinary() and returns sequence
def generateseq(binary):
    string = wrap(binary,2)
    seq = []
    for n, i in enumerate(string):
        if i == "00":
            seq.append( "A")
        elif i == "01":
            seq.append ("C")
        elif i == "10":
            seq.append ("G")
        else:
            seq.append("T")
    seq = (''.join(seq))
    return seq


#generate hex function
# takes Sequence as argument and returns hexadecimal string

def generatehex(seq):
    string = seq
    hexa = []
    for n, i in enumerate(string):
        if i == "A":
            hexa.append( "00")
        elif i == "C":
            hexa.append ("01")
        elif i == "G":
            hexa.append ("10")
        else:
            hexa.append("11")
    hexa = (''.join(hexa))
    hexa = hexa.replace("'","")
    hexa = ("0x%x" % int(hexa,2))
    return hexa

#longest_substring
#find longest substring shared by two sequences

def longest_substring(s1, s2):
    t = [[0]*(1+len(s2)) for i in range(1+len(s1))]
    l, xl = 0, 0
    for x in range(1,1+len(s1)):
        for y in range(1,1+len(s2)):
            if s1[x-1] == s2[y-1]:
                t[x][y] = t[x-1][y-1] + 1
                if t[x][y]>l:
                    l = t[x][y]
                    xl  = x
            else:
                t[x][y] = 0
    return s1[xl-l: xl]

